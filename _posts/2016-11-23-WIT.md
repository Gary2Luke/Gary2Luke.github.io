---
layout: post
title: WIT 写完整性测试
description: WIT
category: blog
---

# WIT 写完整性测试

标签: DFI

---

## Abstract
    用于防止内存错误　　
 WIT在编译时刻用过程间指向性分析[23]计算CFG和程序中可能被每个指令写的一系列objects。然后装备代码防止不在静态分析所得到的集合里的指令修改objects，并且保证间接控制跳转符合DFG。为了提升精确度，WIT在原始的程序objects间插入小的guards。我们描述了一个实现，降低了空间和时间损耗，并且可以实用因为它不用进行修改的编译C和C++程序，没有误报。平均时间损耗7%（CPU密集型benchmarks）。
 
WIT使用指向性分析对每一个object和写操作赋一个color，所有可以被一条指令进行写操作的objecs具有相同的color，装备代码在运行时记录 object  colors并且检查指令写到正确的color。存储单元的color记录在一个color表中，当objects被分配和释放时color表会相应更新。写检查在表中查阅正在被写的存储单元的color并且检查是否和写指令的color一致。如此确保了写完整性。　　

WIT也会给间接跳转指令和可能间接跳转的函数的入口点一个color，由此所有可能被同一条指令call的函数有相同的color。WIT装备代码在color表中记录函数colors并且检查间接跳转指令。间接跳转在表中查找目标地址的color，并且检查是否与间接跳转指令的color匹配。这些检查和写检查确保了CFI。CFI防止攻击者绕过我们的检查并且提供了第二道防线来防御写检查没有探测到的攻击。   

    
    优化：
    1. 静态分析找到不违反写完整性的访问和只有安全访问的objects，我们只装备不安全的写操作，并且对多有安全的objects赋给同样的颜色。这回减少写检查的数目和color表的损耗。降低了需要用来表示color的bit数。我们所有的实验中，一个字节足够表示颜色。
    2. color表使用紧凑表示，可以有效率的查找。color表用一个字节表示一个8字节的存储，降低了12.5%的空间损耗。
    3. Third, we reduce the cost of updating color table entries on function calls. Since most local variables are safe, we only update entries for guards and unsafe variables on function entry and we reset these entries to the color of safe objects on function exit.
    
## Overview
    WIT有compile-time和runtime两个部件。
``` c
// Example vulnerable code: simplified Web server with a buffer overflow vulnerability.

1: char cgiCommand[1024];
2: char cgiDir[1024];
3:
4: void ProcessCGIRequest(char* msg, int sz) {
5: int i=0;
6: while (i < sz) {
7: cgiCommand[i] = msg[i];
8: i++;
9: }
10:
11: ExecuteRequest(cgiDir, cgiCommand);
12: }
```
    lines 5-9 存在缓冲区溢出漏洞，如果message过长，攻击者可以重写cgiDir（里面是CGI commond调用的可执行文件的路径）来运行任意可执行程序（例如shell）。这是一个non-control-data attack，不违反CFI。
    
    使用指向性分析[23]计算程序中每条指令可能修改的obiects，上例中，分析计算出 the set {i} for the instructions at lines 5 and 8, and the set {cgiCommand} for the instruction at line 7.
    
    为了降低运行时的损耗，提出写安全检查来计算安全的指令和objects。不违反写完整性的指令为安全指令，如果所有的能修改object的指令都是安全的，那么这个object是安全的。上例中， instructions 5 and 8 are safe because they can only modify i and, therefore, i is safe. ProcessCGIRequest的参数也是安全的。instruction 7 is not safe because it may modify objects other than cgiCommand depending on i’s value.
    
    对所有的安全指令和objects的color设为0。上例中, 变量 msg, sz, and i and instructions 5 and 8 are assigned color 0 because they are safe. We assign color 3 to variable cgiCommand and instruction 7, and color 4 to variable cgiDir.
    
    为了降低漏报率（由于指向性分析的不精确导致），在原始程序的不安全的objects之间插入小得guards。 Guard objects have color 0 or 1。这些color永远不能赋给不安全的指令以确保WIT能检测到重写guards或者安全的objects。
    
    函数的color集合与objects，guards的color集合不相交。这可以防止不安全的指令重写代码并且防止代码区域外的控制转移。
    
    WIT加了额外的编译阶段来装备以实现写完整性和控制流完整性。有四种类型的instrumention：
to insert guards, to maintain the color table, to check writes, and to check indirect calls. Guards 8个字节大小. 上例中,  add guards just before cgiCommand, between cgiCommand and cgiDir, and just after cgiDir。
    
    当一个object被分配时，把它存储位置的color设为object的color。上例中, WIT adds instrumentation at the beginning of main to set the color of the storage locations occupied by cgiCommand to 3, the color of the storage for cgiDir to 4, and the color of the storage for the guards around them to 0。
    
    为了降低更新color表的损耗，初始化所有存储单元的color表为0，当安全的objects被分配时不更新color表。Instead, we only update the colors for locations corresponding to unsafe objects on function entry. On function exit, we reset color table entries that we updated on function entry to 0. Therefore, there is no instrumentation to update the color table on function entry or exit for ProcessCGIRequest.
    
    上例中, WIT adds write checks only before instruction 7 to check if the location being written has color 3. It does not add write checks before lines 5 and 8 because these instructions are safe。
    
    WIT的防御依赖于指向性分析的精度，比如两个相同color的object可以相互赋值。
    
    WIT可以防御上述例子。The write check before line 7 fails and raises an exception if an attacker attempts to overflow cgiCommand. When i is 1024, the color of the location being written is 0 (which is the color of the guard) rather than 3 (which is the color of cgiCommand). Even without guards, WIT would be able to detect this attack because the colors of cgiCommand and cgiDir are different。
    






